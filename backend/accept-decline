from flask import Flask, request, jsonify
import pymongo
from pymongo import MongoClient
import json 
from bson import json_util
from bson.objectid import ObjectId
 # Mac: export FLASK_APP=app.py flask run
 # To keep it in dev mode continuously: export FLASK_APP=app.py FLASK_ENV=development
 # Talking Points for Presentation: 1. Close closest cluster for lowest latency 2. Chose PyMongo over MongoEngine -- why? 3. Demo Login
 # Talking Points for Presentation: 1. Use closest cluster for lowest latency 2. Chose PyMongo over MongoEngine -- why? 3. Demo Login
 # Notes: 3.7.6 but using Python 3.4 or later -- why?

 # cluster_320 = MongoClient("mongodb://cc320:cc320@320-shard-00-00.8rfoj.mongodb.net:27017,320-shard-00-01.8rfoj.mongodb.net:27017,320-shard-00-02.8rfoj.mongodb.net:27017/320?ssl=true&replicaSet=atlas-mkdts8-shard-0&authSource=admin&retryWrites=true&w=majority")

cluster = MongoClient("mongodb+srv://cc320:cc320@320.8rfoj.mongodb.net/Employees?retryWrites=true&w=majority")
db2 = cluster["Employees"]
collection2 = db2["Requests"]

db = cluster["Employees"]
collection = db["Tiger_Microsystems-employees"]

app = Flask(__name__)


@app.route("/decline/<objectID>", methods=["PUT"])
def decline_request(objectID):
    collection2.update({'_id': ObjectId(objectID)},    # Updating status, but not changing any data
        {
         '$set': {
            'status': "decline"
        }
    }, upsert=False)
    return "Done"

@app.route("/accept/<objectID>", methods=["PUT"])
def accept_request(objectID):
    current_request = collection2.find_one({"_id": ObjectId(objectID)})  # Need to update the actual database.
    collection2.update({'_id': ObjectId(objectID)},
        {
         '$set': {
            'status': "accept"
        }
    }, upsert=False)

    collection.update({'employeeId': current_request["employeeId"]},
        {
         '$set': {
            'managerId': current_request["newManager"]
        }
    }, upsert=False)

    return "Done"
